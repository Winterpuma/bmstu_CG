# Алгоритм  заполнения сплошной области с упорядоченным списком ребер

### **Используемая мной структура(y_group) немного отличается от предложенной эффективной хотя очень на нее похожа. Эта тема покажет списывание на раз два. (советую поменять на то, что просил Куров: обычный связный список.)**  

Это быстродействующий алгоритм, суть которого состоит в сортировке в порядке сканирования точек пересечений ребер многоугольника, 
ограничивающего заданную область, со сканирующими строками.  

### Вопросы на защите
* Алгоритм называется упорядоченный список ребер. Что он упорядочивает? (Если реализовывать наиболее эффективный алгортм: Упорядочивает ребра по наивысшей сканирующей строке их пересекающей. Плохой ответ: пересечения ребер со сканирующей строкой(хотя так оно и есть в не эфф. алгоритме))
* Какой алгоритм реализовали? (Самый эффективный нужно, если на норм баллы)
* Какие есть две категории методов генерации сплошных областей на основе простых описаний ребер или вершин? Какая между ними разница?
1. Растровые - делается попытка определить в порядке сканирования строк принадлежность точки внутренней области контура или многоугольника.
2. Затравочного заполнения - предполагается, что известна некоторая точка (затравка), лежащая внутри замкнутого контура
* Быстродействующий ли алгоритм? (Да) За счет чего?
1. закрашиваем один раз. Назовите примеры когда несколько (по ребрам)
2. не получаем данные о закрашенности текущего пикселя
3. Эффективность повышается за счет использования списка активных ребер. 
* Какую структуру данных вы используете для хранения? (Я - словарь для у группы(Ключ y-координата, значение: список ребер)).
**Используемая мной структура немного отличается от предложенной эффективной хотя очень на нее похожа. Почитайте Роджерса.**
* Какие проблемы есть в вершинах? (Нельзя использовать одинаковое условие (закрашиваем область между точкой первого пересечения ребра и второго) для всех вершин(как-то так) как для ребер) Методы решения: (в локальном экстремуме точку считать за 2 точки пересечения, если вершина не экстремум: за одну).
* А с горизонтальными ребрами что? (Проблема: они парралельны сканирующей строке и одновременно с ней совпадают. Решение: Мы их игнорируем)
* А почему мы можем так сделать? (Потому что конец этого ребра будет учтен в смежном ребре)

### Алгоритм
Процесс реализации алгоритма можно разбить на два этапа: 
* подготовка (сортировка) данных
* преобразование отсортированных данных в растровую форму.  

При реализации данного алгоритма большое время уходит на подготовку данных, 
для этого необходимо определить для каждого ребра многоугольника точки пересечений со строками сканирования, 
проведенными через середины интервалов, используя уже реализованные алгоритм Брезенхема или цифровой дифференциальный анализатор. 
Горизонтальные ребра не могут пересекать сканирующую строку и, следовательно, игнорируются. 
Но при синтезе изображения они, естественно, присутствуют , ибо формируются верхней и нижней строками пикселей. 

* Каждое пересечение ( x, y+1/2 ) заносится в список.
* Затем список отсортировывается по строкам и по возрастанию абсциссы в строке ( то есть точка с координатами ( x1,y1 ) 
будет предшествовать точке с координатами ( x2,y2 ) в том случае, если y1>y2 или при равных ординатах точек - x1<=x2.
* После подготовки данных, они преобразуются в растровую форму, для этого из отсортированного списка выделяются пары точек 
( x1,y1 ) и ( x2,y2 ) ( они соответствуют условию предыдущего абзаца) и на сканирующей строке инициализируются точки с 
целыми значениями x, которые соответствуют неравенству: x1 <= x+1/2 <= x2. 

При реализации данного алгоритма дополнительные **трудности** возникают при пересечении сканирующей строки и многоугольника 
точно по вершине (рис.4.1). При использовании соглашений о середине интервала между строками сканирования возможен случай, 
когда получится нечетное количество пересечений. И,следовательно, разбиение пикселей на пары даст неверный результат.  

Правильный результат в этом случае получается, если учитывать точку пересечения в вершине два раза в том случае, 
если она является **точкой локального минимума или максимума**, и один раз в противном случае. 
Локальный максимум или минимум многоугольника в исследуемой вершине определяется с помощью проверки концевых точек ребер, 
соединенных в данной вершине. Если у обоих конечных точек ординаты y больше, чем у вершины, значит вершина является **точкой 
локального минимума**. Если одна больше, а другая меньше, значит вершина - **точка локального максимума**. 

Если же одна ордината больше, а другая меньше, значит вершина не является ни точкой локального минимума, 
ни точкой локального максимума ( на рис. 4.1. т. V1 - локальный максимум, V3 - локальный минимум, тт. V2,V4 не являются ни 
локальным минимумом , ни локальным максимумом; то есть при пересечении в тт. V1, V3 учитывается два пересечения со строками 
сканирования, а в тт. V2 и V4 - одно).  

## У-группы (более эффективный алгоритм)
Вышеописанный алгоритм с упорядоченным списком ребер требует формирования большого списка точек пересечений, 
который должен быть полностью отсортирован. Поэтому разработан **более эффективный алгоритм** с упорядоченным списком ребер, 
в котором процесс сортировки разделяется по строкам в направлении y и в строке в направлении x с помощью групповой сортировки по y.
* При подготовке данных аналогичным образом определяются точки пересечений ребер многоугольника со строками сканирования
* Затем координата x точки пересечения помещается в группу, соответствующую y. Для каждой такой y-группы отсортировываются 
точки пересечений в порядке возрастания координаты абсцисс, то есть x1 предшествует в отсортированном списке x2, если x1 <= x2. 
* Затем отсортированные данные преобразовываются в растровую форму, то есть для каждой строки сканирования выделяются из 
списка абсцисс точек пересечений пары точек пересечений и на соответствующей строке сканирования - y активизируются пиксели для их 
целых значений ( как и в предыдущем случае ).  

Таким образом, модифицируя простой алгоритм с упорядочен¬ным списком ребер мы сначала с помощью групповой сортировки по 
оси ординат проводим сортировку в порядке сканирования строк, а затем сортируем в строке по оси абсцисс, 
то есть начинаем процесс развертки до окончания сортировки.  
Как видно из алгоритма, в нем легче добавлять или удалять информацию из сортировочного списка, а следовательно, и дисплейного файла: 
необходимо только добавить или удалить информацию из соответствующей y-группы и пересортировать только измененные строки.
Несмотря на то, что при использовании y-групп задача сортировки упрощается, 
при реализации модифицированного алгоритма с упорядоченным списком ребер требуется резервировать **большое количество памяти**
( значительная часть которой не будет использована ) или ограничивать число пересечений с данной сканирующей строкой.  

## Связанный список активных ребер (еще более эффективный алгоритм)
Эти недостатки легко преодолеваются благодаря введению добавочной структуры данных - **связанного списка активных ребер (САР)**.
В этом случае значительно сокращается потребность в памяти, а точки пересечения со строками сканирования вычисляются в пошаговом режиме. 
В процессе подготовки данных в алгоритме с упорядоченным списком ребер, использующем список активных ребер необходимо 
* Определить для каждого ребра многоугольника наивысшую сканирующую строку, пересекаемую данным ребром. 
Это удобно сделать анализируя строки сканирования, проведенные через середины отрезков ( через y+1/2). 
* Затем ребро многоугольника сохраняется в y-группе, соответствующей этой сканирующей строке 
* формируется связанный список, в который заносятся следующие значения: 
1) начальное значение абсцисс точек пересечения -x;
2) число сканирующих строк, пересекаемых ребром многоугольника - y; 
3) шаг приращения по оси абсцисс при переходе от одной строки сканирования к другой - x.  

* В процесе преобразования подготовленных данных в растровую форму для каждой строки сканирования осуществляется проверка соответствующей 
y-группы на наличие новых ребер, в случае их обнаружения, соответствующие значения заносятся в САР. 
* После чего координаты абсцисс точек пересечения из связанного списка отсортировываются в порядке возрастания ( то есть x1 <= x2 ) 
и из него выделяются пары точек, с помощью которых активизируются пиксели на строке сканирования для целых значений x аналогично 
двум предыдущим случаям.
* Затем для каждого ребра из САР число сканирующих строк, пересекаемых данным многоугольником - y, уменьшается на 1. 
* Если в результате, y становится меньше 0, то данное ребро исключается из САР и вычисляется новое начальное значение 
координаты абсцисс точек пересечения xn = x + x. 
* Затем переходят к новой строке сканирования и этапы реализации алгоритма повторяются.  

Так как в данном алгоритме минимизированы операции ввода/вывода, то при реализации можно сделать его независящим от устройств.
